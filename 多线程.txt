竟态条件：多个执行流竞争执行
函数的可重入与不可重入：
	函数的重入：多个执行流同时进入一个函数执行代码
	可重入：函数重入不会造成数据二义，或者逻辑混乱
	不可重入：函数重入可能会造成数据二义，或者逻辑混乱
	关键点：是否对全局数据进行非原子安全操作
SIGCHLD信号：子进程退出后操作系统给父进程发送的通知信息
这个信号默认的处理方式，就是什么也不做，因此子进程退出后在不等待的情况下会成为僵尸进程
这个信号是非可靠信号，意味着大量子进程同时退出的时候，有可能造成时间丢失
volatile关键字：保持内存可见性，防止编译器过度优化，cpu每次都需要重新到内存中获取被修饰变量的数据
gcc -o0/1/2
多线程：线程概念、线程控制、线程安全概念与实现、线程池+单例模式
线程概念：linux下的线程是一个轻量级线程，是通过pcb描述实现的，并且同一个进程组中的线程共用同一个虚拟地址空间，因此这个Linux下的pcb相较于传统pcb更加轻量化，因此叫轻量级教程。
线程是cpu调度的基本单位/进程是系统资源分配的基本单位

多线程/多线程进行多任务处理的优缺点分析：
多线程：
1.进程间通信更加方便灵活
2.线程的创建与销毁成本更低
3.线程间的调度切换成本更低
缺点：1.线程间缺乏访问控制，一切异常和系统调用直接针对整个进程生效
多进程：
稳定性，健壮性更高，适用于主程序安全性要求更高的服务（shell/服务器）

多线程和多线程进行多任务处理的优势在哪里？
	1.IO密集型程序（在程序中大量进行io操作）（IO操作：IO等待+数据拷贝）
	2.CPU密集型程序（在程序中大量进行数据运算）

线程的独有与共享
独有:栈，寄存器，线程标识，优先级，errno信号屏蔽字
共享：自拟地址空间（代码段+文件段）文件描述符表，信号处理方式当前工作路径、用户ID、组ID

	线程控制：线程创建/线程退出/线程等待/线程分离
		线程创建：并没有给用户直接提供创建一个线程的接口，因此封装了一套线程库，用于线程控制。（pthread函数）
		功能：创建一个新的线程
		原型
			 int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void*), void *arg){ };
		参数
			 thread:返回线程ID
			 attr:设置线程的属性，attr为NULL表示使用默认属性
			 start_routine:是个函数地址，线程启动后要执行的函数
			 arg:传给线程启动函数的参数
		返回值：成功返回0；失败返回错误码
		错误检查:
		1.传统的一些函数是，成功返回0，失败返回-1，并且对全局变量errno赋值以指示错误。
		2.pthreads函数出错时不会设置全局变量errno（而大部分其他POSIX函数会这样做）。而是将错误代码通过返回值返回
		3.pthreads同样也提供了线程内的errno变量，以支持其它使用errno的代码。对于pthreads函数的错误，建议通过返回值业判定，因为读取返回值要比读取线程内的errno变量的开销更小
		tid:线程地址空间首地址 pcb->pid:轻量级进程ID pcb->tgid:进程ID值默认等于主线程的pid
		ps-L:查看轻量级进程信息 	LWP
	线程终止：
		1.线程将自己的入口函数运行完毕return退出（main中return退出的是进程）
		2.pthread_exit(void *retval)退出调用线程
		3.void pthread_cancel(pthread_t tid);取消一个指定的线程
	线程退出也不会完全释放资源，需要被其他线程等待
	线程等待：等待一个指定的线程的退出，获取这个线程等待的退出值，并且回收资源
		功能：等待线程结束
		原型
			 int pthread_join(pthread_t thread, void **value_ptr);
		参数
			 thread:线程ID
			 value_ptr:它指向一个指针，后者指向线程的返回值
		返回值：成功返回0；失败返回错误码

		一个线程创建出来，默认在推出的时候是不会释放所有资源的，这是因为线程只有一个属性――joinable
		      处于这个joinable状态的线程，退出后不会自动释放资源，需要被等待。
	线程分离：默认情况下，新创建的线程是joinable的，线程退出后，需要对其进行pthread_join操作，否则无法释放资源，从而造成系统泄漏。
		       如果不关心线程的返回值，join是一种负担，这个时候，我们可以告诉系统，当线程退出时，自动释放线程资源。
		将线程的属性从joinable设置为detach，表示分离一个线程被分离，处于detach属性的线程退出后，则会自动释放所有资源（被分离的线程没必要被等待）
			int pthread_detach(pthread_t thread);
			可以是线程组内其他线程对目标线程进行分离，也可以是线程自己分离pthread_detach(pthread_self());joinable和分离是冲突的，一个线程不能既是joinable又是分离的。
	线程安全：概念+实现
		概念：多个执行流对同一个临界资源进行争抢访问，但是不会造成数据二义。
		实现：
		同步：通过条件判断实现对临界资源访问的时序合理。（不能访问则等待，能够访问则唤醒）
		互斥：同一时间只能有一个执行流能够访问临界安全，实现数据操作安全。
		互斥的实现：互斥锁/信号量
		同步的实现：条件变量/信号量
		生产者与消费者模型/读者写者模型―读写锁/自旋锁





